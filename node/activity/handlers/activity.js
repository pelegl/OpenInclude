// Generated by CoffeeScript 1.4.0
var ActivityHandler, EventEmitter2, Events, Module, Snapshot, Tasks, async, console, get_models, git, hour, util, _ref, _ref1,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Tasks = require('../tasks');

_ref = require('../../source/conf'), get_models = _ref.get_models, git = _ref.git;

_ref1 = get_models(["Module", "Snapshot", "ModuleEvents"]), Module = _ref1[0], Snapshot = _ref1[1], Events = _ref1[2];

console = require('tracer').colorConsole();

async = require('async');

EventEmitter2 = require('eventemitter2').EventEmitter2;

util = require('util');

hour = 60 * 60;

ActivityHandler = (function(_super) {

  __extends(ActivityHandler, _super);

  function ActivityHandler() {
    this.type = 'activity';
    this.on('success', this.success);
    this.on('release', this.release);
    this.on('bury', this.bury);
    this.on('error', this.error);
  }

  ActivityHandler.prototype.success = function(data, callback) {
    var module, snapshot_id,
      _this = this;
    snapshot_id = data.snapshot_id, module = data.module;
    return Snapshot.update_progress(snapshot_id, module, function(err, to_process) {
      if (err != null) {
        return _this.emit('error', err, callback);
      }
      _this.logger.info("items left to process " + to_process);
      return callback('success');
    });
  };

  ActivityHandler.prototype.release = function(delay, callback) {
    this.logger.info("Limit reached - delaying task");
    return callback('release', delay);
  };

  ActivityHandler.prototype.bury = function(callback) {
    return callback('bury');
  };

  ActivityHandler.prototype.error = function(err, callback) {
    return callback(err);
  };

  /*
    work(jobdata, callback(action, delay))
  
    jobdata: job payload
    action: 'success' | 'release' | 'bury' | custom error message
    delay: time to delay if the job is released; otherwise unused
  */


  ActivityHandler.prototype.work = function(payload, callback) {
    var module, name, process, repo, snapshot_id,
      _this = this;
    module = payload.module, snapshot_id = payload.snapshot_id;
    name = "" + module.owner + "/" + module.module_name;
    repo = git.repo(name);
    this.logger.info("Processing " + name);
    process = function(page) {
      return repo.events(page, function(err, response, headers) {
        var limit;
        if (err != null) {
          return _this.emit('error', err, callback);
        }
        limit = Tasks.limit(headers);
        if (limit % 50 === 0) {
          console.info("Current limit: %d", limit);
        }
        /*
                  Process events here
        */

        return Events.publish(module._id, response, function(err) {
          var last, next, _ref2;
          if (err != null) {
            return _this.emit('error', err, callback);
          }
          try {
            _ref2 = Tasks.getPageLinks(headers.link), next = _ref2.next, last = _ref2.last;
            console.log(next, last);
          } catch (e) {
            _this.logger.error(e);
            return _this.emit('success', payload, callback);
          }
          if (next == null) {
            return _this.emit('success', payload, callback);
          }
          if (!(limit > 0)) {
            return _this.emit("release", hour, callback);
          }
          return process(parseInt(next.replace(/.*&page=(\d+)/, "$1")));
        });
      });
    };
    return Snapshot.findOne({
      _id: snapshot_id,
      processed: false
    }, "_id", function(err, snapshot) {
      if (!snapshot) {
        return _this.emit('error', 'no snapshot', callback);
      }
      return git.limit(function(err, left, max) {
        if (left <= 0 || (err != null ? err.message : void 0) === 'Client rate_limit error') {
          return _this.emit("release", hour, callback);
        }
        if (err != null) {
          return _this.emit('error', err, callback);
        }
        return process(1);
      });
    });
  };

  return ActivityHandler;

})(EventEmitter2);

module.exports = function(logger) {
  var handler;
  handler = new ActivityHandler();
  if (logger) {
    handler.logger = logger;
  }
  return handler;
};
