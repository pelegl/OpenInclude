// Generated by CoffeeScript 1.6.1
/*
  Config
*/

var Events, ObjectId, StackOverflow, Stargazers, async, definition, get_models, git, index, methods, options, statics, ts_ago, virtuals, _, _ref, _ref1,
  __slice = [].slice;

ObjectId = require('mongoose').Schema.Types.ObjectId;

_ref = require('../conf'), get_models = _ref.get_models, git = _ref.git;

async = require('async');

_ = require('underscore');

_ref1 = get_models(["StackOverflow", "ModuleStargazers", "ModuleEvents"]), StackOverflow = _ref1[0], Stargazers = _ref1[1], Events = _ref1[2];

/*
  Definition
*/


definition = {
  username: String,
  description: String,
  pushed: Date,
  owner: String,
  is_a_fork: Boolean,
  watchers: Number,
  stars: Number,
  language: String,
  created: Date,
  pushed_at: Date,
  followers: Number,
  module_name: String,
  openinclude_followers: [
    {
      type: ObjectId,
      ref: 'User'
    }
  ],
  github_subscriptions: [
    {
      url: String,
      updated_at: Date,
      created_at: Date,
      name: String,
      events: [],
      active: Boolean,
      config: {},
      id: Number
    }
  ]
};

ts_ago = function(days, toSeconds) {
  var stopDate, stopTS;
  if (toSeconds == null) {
    toSeconds = true;
  }
  stopDate = new Date();
  stopDate.setDate(-days);
  if (toSeconds) {
    stopTS = Math.round(stopDate.getTime() / 1000);
  } else {
    stopTS = stopDate.getTime();
  }
  return stopTS;
};

statics = {
  get_module: function(name, callback) {
    var module_name, owner, _ref2;
    console.log("Started looking for the module");
    try {
      _ref2 = name.split("|"), owner = _ref2[0], module_name = _ref2[1];
      if (!owner || !module_name) {
        throw "incorrect module path";
      }
    } catch (e) {
      return callback("incorrect module name");
    }
    return this.findOne({
      module_name: module_name,
      owner: owner
    }, callback);
  }
};

methods = {
  repo: function() {
    return git.repo("" + this.username + "/" + this.module_name);
  },
  list_stargazers: function() {
    var callback, params, _i, _ref2;
    params = 2 <= arguments.length ? __slice.call(arguments, 0, _i = arguments.length - 1) : (_i = 0, []), callback = arguments[_i++];
    return (_ref2 = this.repo()).stargazers.apply(_ref2, __slice.call(params).concat([callback]));
  },
  make_stargazers_snapshot: function(stargazers, snaphost_date, callback) {
    var snapshot_date,
      _this = this;
    snapshot_date = snapshot_date || new Date();
    return async.forEach(stargazers, function(stargazer, async_call) {
      return Stargazers.create(_this._id, snapshot_date, stargazer, async_call);
    }, callback);
  },
  /*
    @function
    Pulls all events for the given repo for the given time
  */

  get_events: function() {
    var callback, opts, stopTS, _i;
    opts = 2 <= arguments.length ? __slice.call(arguments, 0, _i = arguments.length - 1) : (_i = 0, []), callback = arguments[_i++];
    stopTS = ts_ago(opts[0] || 365, false);
    return Events.pull_for_module(stopTS, this._id, callback);
  },
  /*  
    @function
    Functions pulls questions associated with the module for that past 365 days or opts[0], 
    sorts them by timestamp, creates additional series for answered questions,
    after that adds cummulative {@param amount - number} which indicates how many answers/questions been asked/answered at given timestamp
  */

  get_questions: function() {
    var Tasks, callback, opts, stopTS, _i,
      _this = this;
    opts = 2 <= arguments.length ? __slice.call(arguments, 0, _i = arguments.length - 1) : (_i = 0, []), callback = arguments[_i++];
    stopTS = ts_ago(opts[0] || 365);
    Tasks = {};
    Tasks.statistics = function(statistics) {
      var group, match, project_one, project_two;
      match = {
        $match: {
          module_id: _this._id,
          last_activity_date: {
            $lt: stopTS
          }
        }
      };
      project_one = {
        $project: {
          accepted_answer_id: {
            $ifNull: ["$accepted_answer_id", -1]
          }
        }
      };
      project_two = {
        $project: {
          accepted_asnwer_id: {
            $cond: [
              {
                $ne: ["$accepted_answer_id", -1]
              }, "Total questions asked", "Total questions answered"
            ]
          },
          count: {
            $add: [1]
          }
        }
      };
      group = {
        $group: {
          _id: "$accepted_asnwer_id",
          num: {
            $sum: "$count"
          }
        }
      };
      return StackOverflow.aggregate(match, project_one, project_two, group, function(err, data) {
        var response;
        response = {
          total: 0,
          answered: 0,
          keys: ["Total questions asked", "Total questions answered"]
        };
        return async.forEach(data, function(item, call) {
          response.total += item.num;
          if (item._id === "true") {
            response.answered += item.num;
          }
          return call(null);
        }, function() {
          return statistics(err, response);
        });
      });
    };
    Tasks.questions = [
      "statistics", function(questions_callback, results) {
        var workflow;
        workflow = {};
        workflow.questions = function(questions) {
          var fields, query;
          query = {
            module_id: _this._id,
            last_activity_date: {
              $gte: stopTS
            }
          };
          fields = "question_id creation_date accepted_answer_id answers.is_accepted answers.last_activity_date";
          return StackOverflow.find(query, fields, questions);
        };
        workflow.answered = [
          'questions', function(return_questions, data) {
            var output;
            output = [];
            return async.each(data.questions, function(question, async_callback_each) {
              output.push({
                _id: question.question_id,
                key: "Total questions asked",
                timestamp: question.creation_date
              });
              if (question.accepted_answer_id != null) {
                return async.detect(question.answers, function(answer, call_detect) {
                  return call_detect(answer.is_accepted === true);
                }, function(answer) {
                  output.push({
                    _id: "" + question.question_id + "_answered",
                    key: "Total questions answered",
                    timestamp: answer.last_activity_date,
                    answer: true
                  });
                  return async_callback_each(null);
                });
              } else {
                return async_callback_each(null);
              }
            }, function(err) {
              return return_questions(err, output);
            });
          }
        ];
        workflow.sorted = [
          'answered', function(questions, data) {
            return async.sortBy(data.answered, function(question, async_callback) {
              return async_callback(null, question.timestamp);
            }, questions);
          }
        ];
        workflow.final = [
          'sorted', function(questions, data) {
            var sorted, statistics;
            statistics = _.extend({}, results.statistics);
            sorted = data.sorted;
            return async.eachSeries(sorted, function(question, async_call) {
              if (question.answer === true) {
                question.amount = ++statistics.answered;
              } else {
                question.amount = ++statistics.total;
              }
              return async_call(null);
            }, function() {
              return questions(null, sorted);
            });
          }
        ];
        return async.auto(workflow, function(err, data) {
          if (err != null) {
            return questions_callback(err);
          }
          return questions_callback(null, data.final);
        });
      }
    ];
    return async.auto(Tasks, callback);
  }
};

virtuals = {
  get: {
    url: function() {
      return "https://github.com/" + this.owner + "/" + this.module_name;
    }
  },
  set: {}
};

options = {
  toObject: {
    virtuals: true
  },
  toJSON: {
    virtuals: true
  }
};

index = [
  [
    {
      stars: -1
    }
  ]
];

exports.index = index;

exports.options = options;

exports.virtuals = virtuals;

exports.definition = definition;

exports.statics = statics;

exports.methods = methods;
